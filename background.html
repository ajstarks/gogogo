<script>
root = "http://golang.org/pkg/";

// This event is fired each time the user updates the text in the omnibox,
// as long as the extension's keyword mode is still active.
chrome.omnibox.onInputChanged.addListener(
  function(text, suggest) {
    console.log('inputChanged: ' + text);
	// I'll fill in suggestions once I can properly grab the data
/*    suggest([
      {content: text + " one", description: "the first one"},
      {content: text + " number two", description: "the second entry"}
    ]);*/
  });

// This event is fired with the user accepts the input in the omnibox.
chrome.omnibox.onInputEntered.addListener(
  function(text) {
    console.log('inputEntered: ' + text);
    //alert('You just typed "' + text + '"');
	openTab(root + text);
  });

var myTab;

function openTab(url) {
	var args = {'url' : url, 'selected':true};
	chrome.tabs.create(args, function(tab) {myTab = tab;})
}

// This always seems to return -1. Is a new tab not a tab?
function getCurrentTabId() {
  var id = -1;
  chrome.windows.getCurrent(
    function(win) {
      for(var i=0; i < win.tabs.length; i++) {
        var tab = win.tabs[i];
        if (tab.active) {
          id = tab.id;
        }
      }
    }
  );
  return id;
}

var Entries = [];
var Parsed = false;

function parseDocList(raw) {
	if Parsed {
		return
	}
	
	var rawHTML = raw.match(/<table.*?>([\s\S]*?)<\/table>/)[1];

	alert("raw html:" + rawHTML);

	var docTable = document.create("table");
	docTable.innerHTML = rawHTML;
	
	var entries = docTable.querySelectorAll("td > a");
	
	alert("found " + entries.length + " entries");
	
	for(var i = 0; i < entries.length; i++ ) {
		var entry = entries[i];
		description = getDescription(entry);
		addEntry({'path': entry.href, 'name': entry.innerText, 'desc' : description})		
	}	
	
	alert("Entries:" + JSON.stringify(Entries))
	
	Parsed = true;
}
function addEntry(entry) {
	if (Entries.length == 0) {
		Entries.push(entry)
	} else {
		index = getInsertionIndex([0,Entries.length-1], entry.path);
		console.log("Should insert at:" + index)
		var firstHalf = Entries.slice(0, index);
		var lastHalf = Entries.slice(index, Entries.length);
		Entries = firstHalf.concat([entry]).concat(lastHalf);
	}
}

function getInsertionIndex(range, path) {
	var spread = range[1] - range[0];

	if (spread == 0) {
		if (path > Entries[range[0]]) {
			return range[0]+1;
		} else {
			return range[0]
		}		
	}

    if (spread == 1) {
		if (Entries[range[0]] < path) {
			if (path < Entries[range[1]]) {
				return range[0];
			} else {
				return range[1];
			}
		}
	}

	var pivot = Math.floor( (range[0] + range[1])/2 );
	var pivotValue = Entries[pivot].path;	
	var low = range[0];
	var high = range[1];
		
	if (pivotValue > path) {
		high = pivot;
	} else {
		low = pivot;
	}

	return getInsertionIndex([low, high], path);
}

function getDescription(entry) {
	var descElem = null;
	var desc = "";
	var candidates = entry.parentElement.querySelector("td");
	for(var i=0; i < candidates.length; i++) {
		var candidate = candidates[i];
		if (candidate != entry) {
			descElem = candidate;
		}
	}
	
	if (descElem !== null) {
		desc = descElem.innerText;
	}
	
	return desc;
}

function fetchDocList() {
	alert("fetching")
	var url = "http://golang.org/pkg/";
	
    var xhr = new XMLHttpRequest();
    xhr.addEventListener('readystatechange', function(evt) {
      if (xhr.readyState == 4 && xhr.responseText) {
        parseDocList(xhr.responseText);
      }
    });
    xhr.open('GET', url, true);
    xhr.send();	
}

fetchDocList();

</script>
